---
layout: post
title: Aerospace Projects Portfolio
subtitle: From rocket simulations to space robotics
tags: [projects, aerospace, portfolio]
author: Abhishek Siwakoti
---

Welcome to my aerospace projects portfolio! Each section showcases a different project I‚Äôve worked on, with interactive image galleries to show progress, results, and final implementations.

---

## üöÄ ASEN 2804 Lab 1 ‚Äì Boost-Glide Vehicle Modeling

As the team leader, I led the design and simulation of a boost-glide vehicle. This involved developing a thrust model from static test data, coding aerodynamic models for lift, drag, and weight, and integrating flight dynamics for the entire trajectory‚Äîfrom launch to glide.

Here is the complete report and presentation slides for ASEN 2804 Lab 1. Use the buttons below to view each slide interactively:

<div id="pdf3-controls" style="text-align:center; margin-bottom: 1em;">
  <button onclick="prevPDFPage3()">‚¨Ö Prev</button>
  <span>Page <span id="pdf3-page-num">1</span> of <span id="pdf3-page-count">?</span></span>
  <button onclick="nextPDFPage3()">Next ‚û°</button>
</div>

<canvas id="pdf3-canvas" style="border:1px solid #ccc; display: block; margin: auto;"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
<script>
  const pdf3Url = '/assets/pdfs/2804_Pres.pdf'; // Make sure filename has no spaces
  let pdf3Doc = null, pdf3PageNum = 1, pdf3Rendering = false, pdf3PendingPage = null;
  const pdf3Canvas = document.getElementById('pdf3-canvas');
  const pdf3Ctx = pdf3Canvas.getContext('2d');
  const pdf3Scale = 1.3;

  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

  function renderPDF3Page(num) {
    pdf3Rendering = true;
    pdf3Doc.getPage(num).then(function(page) {
      const viewport = page.getViewport({ scale: pdf3Scale });
      pdf3Canvas.height = viewport.height;
      pdf3Canvas.width = viewport.width;

      const renderContext = { canvasContext: pdf3Ctx, viewport: viewport };
      const renderTask = page.render(renderContext);

      renderTask.promise.then(function() {
        pdf3Rendering = false;
        if (pdf3PendingPage !== null) {
          renderPDF3Page(pdf3PendingPage);
          pdf3PendingPage = null;
        }
      });
    });

    document.getElementById('pdf3-page-num').textContent = num;
  }

  function queueRenderPDF3Page(num) {
    if (pdf3Rendering) {
      pdf3PendingPage = num;
    } else {
      renderPDF3Page(num);
    }
  }

  function prevPDFPage3() {
    if (pdf3PageNum <= 1) return;
    pdf3PageNum--;
    queueRenderPDF3Page(pdf3PageNum);
  }

  function nextPDFPage3() {
    if (pdf3PageNum >= pdf3Doc.numPages) return;
    pdf3PageNum++;
    queueRenderPDF3Page(pdf3PageNum);
  }

  pdfjsLib.getDocument(pdf3Url).promise.then(function(pdfDoc_) {
    pdf3Doc = pdfDoc_;
    document.getElementById('pdf3-page-count').textContent = pdf3Doc.numPages;
    renderPDF3Page(pdf3PageNum);
  });
</script>

---

## üõ†Ô∏è ASEN 2803 Lab 1 ‚Äì VR Roller Coaster G-Force Modeling

For this project, our team designed a virtual roller coaster intended as a pilot simulator using VR goggles. Each group member was responsible for a different track element: a loop, a zero-G parabola, a banked turn, and a braking section. We created MATLAB functions to model the normal, tangential, and lateral G-forces experienced by a cart through these segments and visualized the data to verify safe acceleration limits.

I contributed significantly to the braking and loop sections, handling both derivations and implementation. We validated the loop physics through centripetal force modeling, simulated weightlessness on the parabola with zero normal force, minimized lateral forces on the banked turn through proper geometry, and implemented a constant deceleration profile for braking.

The full MATLAB simulation allowed us to assess g-forces throughout the track, showing our system stayed within safe limits. Key takeaways included learning how to simulate complex motion in MATLAB and understanding the importance of transitions and force smoothing in ride design.

Below is the full 12-page report, viewable one page at a time:

<div id="pdf-controls" style="text-align:center; margin-bottom: 1em;">
  <button onclick="prevPDFPage()">‚¨Ö Prev</button>
  <span>Page <span id="pdf-page-num">1</span> of <span id="pdf-page-count">?</span></span>
  <button onclick="nextPDFPage()">Next ‚û°</button>
</div>

<canvas id="pdf-canvas" style="border:1px solid #ccc; display: block; margin: auto;"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
<script>
  const url = '/assets/pdfs/2803_Dynamics_Lab_Report.pdf'; // Adjust path if needed
  let pdfDoc = null, pageNum = 1, pageRendering = false, pageNumPending = null;
  const scale = 1.3;
  const canvas = document.getElementById('pdf-canvas');
  const ctx = canvas.getContext('2d');

  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

  function renderPDFPage(num) {
    pageRendering = true;
    pdfDoc.getPage(num).then(function(page) {
      const viewport = page.getViewport({ scale: scale });
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      const renderContext = { canvasContext: ctx, viewport: viewport };
      const renderTask = page.render(renderContext);
      renderTask.promise.then(function() {
        pageRendering = false;
        if (pageNumPending !== null) {
          renderPDFPage(pageNumPending);
          pageNumPending = null;
        }
      });
    });
    document.getElementById('pdf-page-num').textContent = num;
  }

  function queueRenderPage(num) {
    if (pageRendering) {
      pageNumPending = num;
    } else {
      renderPDFPage(num);
    }
  }

  function prevPDFPage() {
    if (pageNum <= 1) return;
    pageNum--;
    queueRenderPage(pageNum);
  }

  function nextPDFPage() {
    if (pageNum >= pdfDoc.numPages) return;
    pageNum++;
    queueRenderPage(pageNum);
  }

  pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
    pdfDoc = pdfDoc_;
    document.getElementById('pdf-page-count').textContent = pdfDoc.numPages;
    renderPDFPage(pageNum);
  });
</script>

---

## ‚öôÔ∏è ASEN 2803 Lab 2 ‚Äì Locomotive Crank: Modeling & Experimental Validation

In this lab, we investigated the kinematics of a locomotive crank mechanism, which demonstrates general planar motion through a rotating disk and a translating collar. I derived a model that related the disk‚Äôs angular position and velocity to the vertical speed of the collar using a combination of geometry and rigid body motion analysis.

We implemented the model in MATLAB (`LCSMODEL.m`) and validated it through simulations. I then analyzed real-world data collected via sensors (a motor encoder and a linear potentiometer), comparing the model predictions to experimental measurements using a structured data processing pipeline (`LCSDATA.m`). Discrepancies between model and experiment were assessed by plotting residuals and computing statistics like mean error and standard deviation.

Key takeaways included identifying noise and small misalignments as dominant error sources, and refining model accuracy by better characterizing system geometry and sensor limitations.

Below is the full lab report. Use the arrows to flip through each page interactively:

<div id="pdf2-controls" style="text-align:center; margin-bottom: 1em;">
  <button onclick="prevPDFPage2()">‚¨Ö Prev</button>
  <span>Page <span id="pdf2-page-num">1</span> of <span id="pdf2-page-count">?</span></span>
  <button onclick="nextPDFPage2()">Next ‚û°</button>
</div>

<canvas id="pdf2-canvas" style="border:1px solid #ccc; display: block; margin: auto;"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
<script>
  const pdf2Url = '/assets/pdfs/ASEN_2803_Lab_2_Locomotive_Crank.pdf'; // Make sure filename has no spaces
  let pdf2Doc = null, pdf2PageNum = 1, pdf2Rendering = false, pdf2PendingPage = null;
  const pdf2Canvas = document.getElementById('pdf2-canvas');
  const pdf2Ctx = pdf2Canvas.getContext('2d');
  const pdf2Scale = 1.3;

  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

  function renderPDF2Page(num) {
    pdf2Rendering = true;
    pdf2Doc.getPage(num).then(function(page) {
      const viewport = page.getViewport({ scale: pdf2Scale });
      pdf2Canvas.height = viewport.height;
      pdf2Canvas.width = viewport.width;

      const renderContext = { canvasContext: pdf2Ctx, viewport: viewport };
      const renderTask = page.render(renderContext);

      renderTask.promise.then(function() {
        pdf2Rendering = false;
        if (pdf2PendingPage !== null) {
          renderPDF2Page(pdf2PendingPage);
          pdf2PendingPage = null;
        }
      });
    });

    document.getElementById('pdf2-page-num').textContent = num;
  }

  function queueRenderPDF2Page(num) {
    if (pdf2Rendering) {
      pdf2PendingPage = num;
    } else {
      renderPDF2Page(num);
    }
  }

  function prevPDFPage2() {
    if (pdf2PageNum <= 1) return;
    pdf2PageNum--;
    queueRenderPDF2Page(pdf2PageNum);
  }

  function nextPDFPage2() {
    if (pdf2PageNum >= pdf2Doc.numPages) return;
    pdf2PageNum++;
    queueRenderPDF2Page(pdf2PageNum);
  }

  pdfjsLib.getDocument(pdf2Url).promise.then(function(pdfDoc_) {
    pdf2Doc = pdfDoc_;
    document.getElementById('pdf2-page-count').textContent = pdf2Doc.numPages;
    renderPDF2Page(pdf2PageNum);
  });
</script>


---

## üß™ ASEN 2803 Lab 3 ‚Äì Rotary Arm: PD Control and System Identification

This lab involved developing and validating a closed-loop control model for a rigid rotary arm using a PD (Proportional-Derivative) controller. I derived and simulated the second-order system dynamics in MATLAB, and used both simulation and hardware experiments to analyze the impact of different gain configurations on overshoot and settling time.

Using feedback from potentiometer readings and calculated angular velocities, I tuned proportional and derivative gains to meet performance criteria‚Äîless than 20% overshoot and 5% settling within 1 second. Experimental plots were compared to MATLAB simulations to analyze modeling accuracy and physical limitations such as motor saturation and friction.

Additionally, I designed and evaluated a flexible arm system using strain gauge feedback. The system was modeled as a two-DOF spring-mass-damper, and a multi-sensor PD control scheme was implemented. I explored the interaction of flexible dynamics with controller gains, identifying sensor-based corrections to reduce tip displacement.

<div class="carousel" id="carousel-4">
  <button class="carousel-btn prev" onclick="plusSlides(-1, 3)">&#10094;</button>
  <div class="carousel-images">
    <img src="/assets/img/asen2803_lab3_sim_response.png" class="carousel-image active" alt="MATLAB Simulated Step Response">
    <img src="/assets/img/asen2803_lab3_hardware_response.png" class="carousel-image" alt="Hardware Response vs. Simulation">
    <img src="/assets/img/asen2803_lab3_control_diagram.png" class="carousel-image" alt="Control Block Diagram">
  </div>
  <button class="carousel-btn next" onclick="plusSlides(1, 3)">&#10095;</button>
</div>

---

## Carousel Script + Styles

Add this block below your post content or into `_includes/scripts.html` for reuse:

```html
<style>
.carousel {
  position: relative;
  max-width: 700px;
  margin: auto;
  margin-top: 1em;
}
.carousel-images {
  position: relative;
  overflow: hidden;
}
.carousel-image {
  display: none;
  width: 100%;
  border-radius: 10px;
}
.carousel-image.active {
  display: block;
}
.carousel-btn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background-color: rgba(0,0,0,0.4);
  color: white;
  border: none;
  font-size: 2em;
  cursor: pointer;
  padding: 0 12px;
  z-index: 1;
}
.carousel-btn.prev { left: 0; }
.carousel-btn.next { right: 0; }
</style>

<script>
let slideIndices = [1, 1, 1]; // One per carousel

function plusSlides(n, carouselIndex) {
  showSlides(slideIndices[carouselIndex] += n, carouselIndex);
}

function showSlides(n, carouselIndex) {
  const carousels = document.querySelectorAll('.carousel');
  const images = carousels[carouselIndex].querySelectorAll('.carousel-image');

  if (n > images.length) slideIndices[carouselIndex] = 1;
  if (n < 1) slideIndices[carouselIndex] = images.length;

  images.forEach(img => img.classList.remove('active'));
  images[slideIndices[carouselIndex] - 1].classList.add('active');
}

document.addEventListener("DOMContentLoaded", () => {
  for (let i = 0; i < slideIndices.length; i++) {
    showSlides(slideIndices[i], i);
  }
});
</script>
